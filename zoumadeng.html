<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Maison du Sillage - Interactive Demo</title>
    <style>
        :root {
            --gold: #d4af37;
            --gold-dim: #8a702a;
            --dark: #0a0a0a;
            --text-main: #e0e0e0;
            --serif: "Georgia", "Times New Roman", Times, serif;
            --sans: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--dark);
            overflow: hidden;
            font-family: var(--sans);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        /* Canvas container */
        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }
        #canvas-container:active {
            cursor: grabbing;
        }

        /* Film Grain Overlay */
        .grain-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
            opacity: 0.04;
            background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
        }

        /* UI Layer */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 20;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
            color: var(--text-main);
        }

        /* Header */
        header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: auto;
        }

        .brand {
            font-family: var(--serif);
            letter-spacing: 0.05em;
        }
        .brand h1 {
            font-size: 1.8rem;
            margin: 0;
            font-weight: 400;
            color: #fff;
        }
        .brand p {
            font-size: 0.85rem;
            margin: 0.3rem 0 0 0.2rem;
            color: var(--gold);
            font-style: italic;
            opacity: 0.8;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 1.5rem;
        }
        
        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.2);
            color: var(--text-main);
            padding: 0.6rem 1.2rem;
            font-family: var(--sans);
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.15em;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            border-radius: 2px;
        }
        button:hover {
            border-color: var(--gold);
            color: var(--gold);
        }
        button.active {
            background: rgba(212, 175, 55, 0.1);
            border-color: var(--gold);
            color: var(--gold);
        }

        /* Footer / Chapters */
        footer {
            pointer-events: auto;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .chapter-title {
            text-align: center;
            margin-bottom: 1rem;
            opacity: 0; 
            transform: translateY(10px);
            transition: opacity 0.8s ease, transform 0.8s ease;
        }
        .chapter-title.visible {
            opacity: 1;
            transform: translateY(0);
        }
        .chapter-title h2 {
            font-family: var(--serif);
            font-weight: 400;
            font-size: 2rem;
            margin: 0;
            color: #fff;
        }
        .chapter-title p {
            font-size: 0.9rem;
            color: var(--gold);
            margin: 0.5rem 0 0 0;
            font-style: italic;
        }

        .carousel-nav {
            display: flex;
            gap: 2rem;
            overflow-x: auto;
            padding: 1rem 2rem;
            max-width: 100%;
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none;  /* IE */
        }
        .carousel-nav::-webkit-scrollbar { display: none; }

        .nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            cursor: pointer;
            opacity: 0.5;
            transition: opacity 0.5s ease, transform 0.5s ease;
            min-width: 60px;
        }
        .nav-item:hover {
            opacity: 0.8;
            transform: translateY(-2px);
        }
        .nav-item.selected {
            opacity: 1;
            transform: translateY(-4px);
        }
        .nav-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #fff;
            transition: background-color 0.3s;
        }
        .nav-item.selected .nav-dot {
            background-color: var(--gold);
            box-shadow: 0 0 8px var(--gold-dim);
        }
        .nav-label {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            #ui-layer { padding: 1.5rem; }
            .brand h1 { font-size: 1.4rem; }
            .chapter-title h2 { font-size: 1.5rem; }
            .carousel-nav { gap: 1.5rem; }
        }
        
        /* Loading Overlay */
        #loader {
            position: absolute;
            top:0; left:0; width:100%; height:100%;
            background: #000;
            z-index: 100;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--gold);
            font-family: var(--serif);
            font-style: italic;
            transition: opacity 1s ease;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loader">Initializing Experience...</div>

    <div class="grain-overlay"></div>

    <div id="ui-layer">
        <header>
            <div class="brand">
                <h1>Maison du Sillage</h1>
                <p>A Whirl of Light</p>
            </div>
            <div class="controls">
                <button id="btn-light">Ignite</button>
            </div>
        </header>

        <footer>
            <div id="chapter-text" class="chapter-title">
                <h2 id="chap-name">Rose</h2>
                <p id="chap-desc">A garden at midnight.</p>
            </div>
            <div class="carousel-nav" id="chapter-nav">
                </div>
        </footer>
    </div>

    <div id="canvas-container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        // --- CONFIGURATION ---
        const CONFIG = {
            chapters: [
                { name: "Rose", desc: "Velvet petals in the moonlight.", color: 0xffe0e0, pattern: "rose" },
                { name: "Figuier", desc: "Warm bark and fresh green sap.", color: 0xe0ffea, pattern: "fig" },
                { name: "Ambre", desc: "Spicy resin and ancient gold.", color: 0xffdcb0, pattern: "amber" },
                { name: "Baies", desc: "Blackcurrant berries and roses.", color: 0xe8e0ff, pattern: "baies" },
                { name: "Feu de Bois", desc: "Crackling embers of winter.", color: 0xffd0a0, pattern: "wood" }
            ],
            shadowSize: Math.min(window.innerWidth > 800 ? 2048 : 1024, 2048),
            bloomStrength: 0.35,
            bloomRadius: 0.8,
            bloomThreshold: 0.85,
            rotationSpeed: 0.003,
            dragInertia: 0.96,
            flameColorCore: new THREE.Color(0xffaa33),
            flameColorOuter: new THREE.Color(0xff4400),
            goldColor: 0xffd700,
        };

        // --- STATE ---
        const state = {
            isLit: false,
            currentChapterIndex: 0,
            rotationVelocity: 0,
            isDragging: false,
            lastPointerX: 0,
            autoRotation: true,
            time: 0
        };

        // --- SCENE GLOBALS ---
        let scene, camera, renderer, composer;
        let flameLight, flameMesh, wickMesh, glowMesh;
        let carouselGroup, charmsGroup;
        let wallMesh;
        const clock = new THREE.Clock();

        // --- INIT ---
        function init() {
            const container = document.getElementById('canvas-container');

            // 1. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: "high-performance" });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            container.appendChild(renderer.domElement);

            // 2. Camera
            camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(0, 3, 7);
            camera.lookAt(0, 0.5, 0);

            // 3. Scene
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050505, 0.02);

            // 4. Lights
            // Ambient (Fill) - very dark
            const ambient = new THREE.HemisphereLight(0x222222, 0x000000, 0.5);
            scene.add(ambient);

            // Flame Light (The Projection Source)
            flameLight = new THREE.PointLight(0xffa95c, 0, 15);
            flameLight.position.set(0, 0.65, 0);
            flameLight.castShadow = true;
            flameLight.shadow.mapSize.width = CONFIG.shadowSize;
            flameLight.shadow.mapSize.height = CONFIG.shadowSize;
            flameLight.shadow.bias = -0.0001;
            flameLight.shadow.radius = 2; // Soft edges
            scene.add(flameLight);

            // Subtle Rim Light for separation
            const rimLight = new THREE.SpotLight(0x445577, 2);
            rimLight.position.set(0, 5, -5);
            rimLight.lookAt(0,0,0);
            scene.add(rimLight);

            // 5. Build Objects
            buildEnvironment();
            buildCandle();
            
            // Initial Carousel
            carouselGroup = new THREE.Group();
            scene.add(carouselGroup);
            loadChapter(0, false);

            // 6. Post Processing
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = CONFIG.bloomThreshold;
            bloomPass.strength = CONFIG.bloomStrength;
            bloomPass.radius = CONFIG.bloomRadius;

            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            // 7. Events
            window.addEventListener('resize', onResize);
            setupInteractions();
            setupUI();

            // Reveal
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => {
                document.getElementById('loader').style.display = 'none';
                document.querySelector('.chapter-title').classList.add('visible');
            }, 1000);

            // Start Loop
            animate();
        }

        // --- GEOMETRY BUILDERS ---

        function buildEnvironment() {
            // Curved Wall
            const wallGeo = new THREE.CylinderGeometry(6, 6, 12, 64, 1, true, Math.PI * 0.8, Math.PI * 1.4);
            const wallMat = new THREE.MeshStandardMaterial({
                color: 0xeae6d8,
                roughness: 0.9,
                side: THREE.BackSide
            });
            wallMesh = new THREE.Mesh(wallGeo, wallMat);
            wallMesh.scale.x = -1; // Invert to face center
            wallMesh.position.z = 2;
            wallMesh.receiveShadow = true;
            scene.add(wallMesh);

            // Floor (Dark Reflection)
            const floorGeo = new THREE.PlaneGeometry(20, 20);
            const floorMat = new THREE.MeshStandardMaterial({
                color: 0x050505,
                roughness: 0.2,
                metalness: 0.5
            });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI / 2;
            floor.position.y = -1;
            floor.receiveShadow = true;
            scene.add(floor);
        }

        function buildCandle() {
            const candleGroup = new THREE.Group();
            
            // Glass Container
            const glassGeo = new THREE.CylinderGeometry(0.8, 0.8, 2, 64);
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffffff,
                metalness: 0,
                roughness: 0.1,
                transmission: 0.95, // Glass
                thickness: 0.1,
                clearcoat: 1.0,
                transparent: true,
                side: THREE.DoubleSide
            });
            const glass = new THREE.Mesh(glassGeo, glassMat);
            glass.castShadow = true; // Glass casts shadow too (caustics simulated by transmission)
            candleGroup.add(glass);

            // Wax (Inside)
            const waxGeo = new THREE.CylinderGeometry(0.75, 0.75, 1.5, 32);
            const waxMat = new THREE.MeshStandardMaterial({
                color: 0xfdf8e4,
                roughness: 0.6,
                metalness: 0.1
            });
            const wax = new THREE.Mesh(waxGeo, waxMat);
            wax.position.y = -0.2;
            wax.receiveShadow = true;
            candleGroup.add(wax);

            // Wick
            const wickGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.4, 8);
            const wickMat = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 1 });
            wickMesh = new THREE.Mesh(wickGeo, wickMat);
            wickMesh.position.y = 0.55;
            candleGroup.add(wickMesh);

            // Flame (Procedural Shader)
            const flameGeo = new THREE.PlaneGeometry(0.35, 0.6);
            flameGeo.translate(0, 0.3, 0); // Pivot at bottom
            
            const flameShader = {
                uniforms: {
                    uTime: { value: 0 },
                    uColorCore: { value: CONFIG.flameColorCore },
                    uColorOuter: { value: CONFIG.flameColorOuter },
                    uOpacity: { value: 0.0 } // Starts off
                },
                vertexShader: `
                    varying vec2 vUv;
                    uniform float uTime;
                    void main() {
                        vUv = uv;
                        vec3 pos = position;
                        // Simple wind/flicker
                        float flicker = sin(uTime * 10.0 + position.y * 5.0) * 0.02 * position.y;
                        pos.x += flicker;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    varying vec2 vUv;
                    uniform vec3 uColorCore;
                    uniform vec3 uColorOuter;
                    uniform float uOpacity;
                    
                    // Simple noise function
                    float hash(float n) { return fract(sin(n) * 43758.5453123); }

                    void main() {
                        if(uOpacity < 0.01) discard;

                        vec2 center = vec2(0.5, 0.2);
                        float dist = distance(vUv, center);
                        
                        // Shape mask (teardrop)
                        float shape = 1.0 - smoothstep(0.0, 0.5, dist * vec2(1.0, 0.5 + vUv.y).x * 2.5);
                        
                        // Core glow
                        float core = 1.0 - smoothstep(0.0, 0.15, dist);
                        
                        vec3 color = mix(uColorOuter, uColorCore, core);
                        
                        // Bottom transparency fade
                        float alpha = shape * uOpacity;
                        alpha *= smoothstep(0.0, 0.1, vUv.y);

                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                side: THREE.DoubleSide,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            };

            const flameMat = new THREE.ShaderMaterial(flameShader);
            flameMesh = new THREE.Mesh(flameGeo, flameMat);
            flameMesh.position.y = 0.65;
            flameMesh.rotation.y = Math.PI / 4; // Face camera roughly
            flameMesh.visible = false;
            candleGroup.add(flameMesh);

            // Interaction Hitbox
            const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), new THREE.MeshBasicMaterial({visible:false}));
            hitbox.position.y = 1;
            hitbox.name = "candle_hitbox";
            candleGroup.add(hitbox);

            scene.add(candleGroup);
        }

        function createPatternedShape(type) {
            const shape = new THREE.Shape();
            // Oval Base
            shape.absellipse(0, 0, 0.5, 0.8, 0, Math.PI * 2, false, 0);

            // Procedural Holes
            const holeCount = 12;
            
            if (type === 'rose') {
                // Swirls
                for(let i=0; i<5; i++) {
                    const hole = new THREE.Path();
                    const angle = (i/5) * Math.PI * 2;
                    const r = 0.25;
                    hole.absellipse(Math.cos(angle)*r, Math.sin(angle)*r, 0.08, 0.15, angle, angle + Math.PI*2);
                    shape.holes.push(hole);
                }
            } else if (type === 'wood') {
                // Vertical jagged lines
                for(let i=-2; i<=2; i++) {
                    if(i===0) continue;
                    const hole = new THREE.Path();
                    const x = i * 0.12;
                    hole.moveTo(x, -0.4);
                    hole.lineTo(x + 0.02, 0);
                    hole.lineTo(x, 0.4);
                    hole.lineTo(x - 0.04, 0.4);
                    hole.lineTo(x - 0.02, 0);
                    hole.lineTo(x - 0.04, -0.4);
                    shape.holes.push(hole);
                }
            } else if (type === 'baies') {
                // Clusters of dots
                for(let i=0; i<15; i++) {
                    const hole = new THREE.Path();
                    const r = Math.random() * 0.35;
                    const theta = Math.random() * Math.PI * 2;
                    hole.absarc(Math.cos(theta)*r, Math.sin(theta)*r, 0.03 + Math.random()*0.04, 0, Math.PI*2);
                    shape.holes.push(hole);
                }
            } else if (type === 'fig') {
                // Leaf-like cutout
                const hole = new THREE.Path();
                hole.moveTo(0, -0.5);
                hole.quadraticCurveTo(0.3, -0.2, 0, 0.5);
                hole.quadraticCurveTo(-0.3, -0.2, 0, -0.5);
                shape.holes.push(hole);
            } else {
                // Amber/Stars
                for(let i=0; i<8; i++) {
                    const hole = new THREE.Path();
                    const r = 0.15 + (i%2)*0.2;
                    const angle = (i/8)*Math.PI*2;
                    hole.absellipse(Math.cos(angle)*r, Math.sin(angle)*r, 0.05, 0.05, 0, Math.PI*2);
                    shape.holes.push(hole);
                }
            }
            return shape;
        }

        function loadChapter(index, animated = true) {
            state.currentChapterIndex = index;
            const data = CONFIG.chapters[index];

            // 1. Build New Carousel Geometry
            if (charmsGroup) {
                // If animated, fade out old one, then remove
                const oldGroup = charmsGroup;
                // Simple fade out via scale/opacity logic would be here
                // For simplicity in single file: remove immediately, but we will animate the transition "feeling" via lights
                scene.remove(oldGroup);
                oldGroup.traverse(o => {
                    if(o.geometry) o.geometry.dispose();
                    if(o.material) o.material.dispose();
                });
            }

            charmsGroup = new THREE.Group();
            charmsGroup.position.y = 2.8; // Height above candle

            // Gold Material
            const goldMat = new THREE.MeshPhysicalMaterial({
                color: CONFIG.goldColor,
                metalness: 1.0,
                roughness: 0.25,
                clearcoat: 0.5,
                side: THREE.DoubleSide
            });

            // Hub
            const hubGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.2, 16);
            const hub = new THREE.Mesh(hubGeo, goldMat);
            charmsGroup.add(hub);

            // Spokes & Charms
            const numCharms = 5;
            const radius = 1.2;
            
            for(let i=0; i<numCharms; i++) {
                const angle = (i / numCharms) * Math.PI * 2;
                
                // Spoke
                const spokeGeo = new THREE.CylinderGeometry(0.02, 0.02, radius, 8);
                spokeGeo.rotateZ(Math.PI / 2);
                spokeGeo.translate(radius/2, 0, 0);
                const spoke = new THREE.Mesh(spokeGeo, goldMat);
                spoke.rotation.y = angle;
                charmsGroup.add(spoke);

                // Charm Geometry (Extruded Shape)
                const shape = createPatternedShape(data.pattern);
                const charmGeo = new THREE.ExtrudeGeometry(shape, {
                    depth: 0.02,
                    bevelEnabled: true,
                    bevelThickness: 0.01,
                    bevelSize: 0.01,
                    bevelSegments: 2
                });
                // Center geometry
                charmGeo.center();
                
                const charm = new THREE.Mesh(charmGeo, goldMat);
                // Position at end of spoke, hanging down
                charm.position.set(Math.cos(angle)*radius, -0.6, Math.sin(angle)*radius);
                // Slight rotation to face outward/tangent
                charm.rotation.y = angle + Math.PI/2;
                charm.castShadow = true;
                charm.receiveShadow = true;
                
                // Add a tiny ring connector
                const ring = new THREE.Mesh(new THREE.TorusGeometry(0.05, 0.01, 8, 16), goldMat);
                ring.position.set(Math.cos(angle)*radius, 0, Math.sin(angle)*radius);
                ring.rotation.y = angle;
                
                charmsGroup.add(ring);
                charmsGroup.add(charm);
            }

            carouselGroup.add(charmsGroup);
            
            // Initial animation pop-in
            charmsGroup.scale.set(0,0,0);
            
            // Animation loop handles scale lerp
            state.targetScale = 1; 

            // Update UI
            updateUI(index);
        }

        // --- INTERACTION LOGIC ---

        function toggleLight() {
            state.isLit = !state.isLit;
            const btn = document.getElementById('btn-light');
            
            if(state.isLit) {
                btn.textContent = "Extinguish";
                btn.classList.add('active');
                flameMesh.visible = true;
                // Light Ramp Up handled in animate
            } else {
                btn.textContent = "Ignite";
                btn.classList.remove('active');
                // Light Ramp Down handled in animate
            }
        }

        function setupInteractions() {
            const container = document.getElementById('canvas-container');
            
            // Mouse/Touch Drag
            const onDown = (x) => {
                state.isDragging = true;
                state.lastPointerX = x;
                state.autoRotation = false;
            };
            const onMove = (x) => {
                if(!state.isDragging) return;
                const delta = x - state.lastPointerX;
                state.rotationVelocity += delta * 0.01; // Sensitivity
                state.lastPointerX = x;
            };
            const onUp = () => {
                state.isDragging = false;
                setTimeout(() => { if(!state.isDragging) state.autoRotation = true; }, 1000);
            };

            container.addEventListener('mousedown', e => onDown(e.clientX));
            window.addEventListener('mousemove', e => onMove(e.clientX));
            window.addEventListener('mouseup', onUp);

            container.addEventListener('touchstart', e => onDown(e.touches[0].clientX), {passive: false});
            window.addEventListener('touchmove', e => onMove(e.touches[0].clientX), {passive: false});
            window.addEventListener('touchend', onUp);

            // Click on candle to light
            const raycaster = new THREE.Raycaster();
            const pointer = new THREE.Vector2();
            container.addEventListener('click', (event) => {
                // Calculate mouse position in normalized device coordinates
                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
                raycaster.setFromCamera( pointer, camera );
                const intersects = raycaster.intersectObjects( scene.children, true );
                
                for(let hit of intersects) {
                    if(hit.object.name === "candle_hitbox" || hit.object === wickMesh || hit.object === flameMesh) {
                        toggleLight();
                        break;
                    }
                }
            });
            
            document.getElementById('btn-light').addEventListener('click', toggleLight);
        }

        function setupUI() {
            const nav = document.getElementById('chapter-nav');
            CONFIG.chapters.forEach((chap, idx) => {
                const div = document.createElement('div');
                div.className = 'nav-item' + (idx === 0 ? ' selected' : '');
                div.innerHTML = `<div class="nav-dot"></div><span class="nav-label">${chap.name}</span>`;
                div.onclick = () => {
                    if(state.currentChapterIndex === idx) return;
                    loadChapter(idx);
                };
                nav.appendChild(div);
            });
        }

        function updateUI(index) {
            const navItems = document.querySelectorAll('.nav-item');
            navItems.forEach((el, i) => {
                if(i === index) el.classList.add('selected');
                else el.classList.remove('selected');
            });

            const titleEl = document.getElementById('chapter-text');
            const nameEl = document.getElementById('chap-name');
            const descEl = document.getElementById('chap-desc');

            // Fade text out
            titleEl.classList.remove('visible');
            
            setTimeout(() => {
                nameEl.textContent = CONFIG.chapters[index].name;
                descEl.textContent = CONFIG.chapters[index].desc;
                titleEl.classList.add('visible');
            }, 600);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
            // Mobile Optimization on resize
            if(window.innerWidth < 600) {
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            }
        }

        // --- ANIMATION LOOP ---

        function animate(t) {
            requestAnimationFrame(animate);

            const dt = clock.getDelta();
            state.time += dt;

            // 1. Rotation Logic
            if(state.isLit && state.autoRotation && !state.isDragging) {
                // Accelerate to target speed
                state.rotationVelocity += (CONFIG.rotationSpeed - state.rotationVelocity) * 0.05;
            } else if (!state.isLit && !state.isDragging) {
                // Decelerate to stop
                state.rotationVelocity *= 0.95;
            }
            
            // Inertia decay if not dragging but moving fast
            if (!state.isDragging && !state.isLit && Math.abs(state.rotationVelocity) > 0.0001) {
                state.rotationVelocity *= CONFIG.dragInertia;
            }

            // Apply rotation
            if(carouselGroup) {
                carouselGroup.rotation.y += state.rotationVelocity;
                
                // Subtle wobbling of charms based on rotation speed
                if(charmsGroup) {
                    const wobble = Math.sin(state.time * 3) * (state.rotationVelocity * 20);
                    // Scale animation (pop-in)
                    const s = THREE.MathUtils.lerp(charmsGroup.scale.x, state.targetScale || 1, 0.1);
                    charmsGroup.scale.set(s,s,s);
                    
                    // Sway charms
                    charmsGroup.children.forEach((child, i) => {
                        if(child.geometry.type === 'ExtrudeGeometry') { // Identify charms
                             // Sway logic
                             child.rotation.z = wobble * 0.5;
                        }
                    });
                }
            }

            // 2. Flame & Light Animation
            if(flameMesh && flameLight) {
                const targetIntensity = state.isLit ? 1.5 : 0;
                const currentIntensity = THREE.MathUtils.lerp(flameLight.intensity, targetIntensity, 0.05);
                flameLight.intensity = currentIntensity;

                // Opacity of flame mesh
                const targetOpacity = state.isLit ? 1.0 : 0.0;
                flameMesh.material.uniforms.uOpacity.value = THREE.MathUtils.lerp(flameMesh.material.uniforms.uOpacity.value, targetOpacity, 0.1);

                if(state.isLit) {
                    flameMesh.material.uniforms.uTime.value = state.time;
                    
                    // Light flicker
                    const flicker = 1.0 + (Math.random() - 0.5) * 0.1;
                    flameLight.intensity = currentIntensity * flicker;
                    
                    // Light Color morphing based on chapter
                    const targetColor = new THREE.Color(CONFIG.chapters[state.currentChapterIndex].color);
                    // We blend the flame color with the chapter color for the light
                    const mixedColor = new THREE.Color(0xffa95c).lerp(targetColor, 0.3);
                    flameLight.color.lerp(mixedColor, 0.05);
                } else {
                    flameMesh.visible = flameMesh.material.uniforms.uOpacity.value > 0.01;
                }
            }

            // Render
            composer.render();
        }

        // Start
        init();

    </script>
</body>
</html>
